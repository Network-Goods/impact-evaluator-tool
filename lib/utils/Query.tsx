import { useState } from "react";
import { is_error, QueryError } from ".";

// Noobs first ReactQuery clone
export function use_query<T>(f: () => Promise<T | QueryError>): QueryResult<T> {
  let resolve_query_promise: (value: T | PromiseLike<T>) => void;
  let query_promise = new Promise<T>((_resolve, reject) => {
    resolve_query_promise = _resolve;
  });

  let [query_state, set_query_state] = useState<InternalQueryResult<T>>({
    status: QueryStatus.idle,
    promise: query_promise,
  });

  function run() {
    if (query_state.status != QueryStatus.idle) {
      return;
    }

    set_query_state({
      status: QueryStatus.loading,
      promise: query_state.promise,
    });

    f().then((value) => {
      if (is_error(value)) {
        console.error("wrap_query failed:", value.message);

        set_query_state({
          status: QueryStatus.errored,
          message: value.message,
          promise: query_state.promise,
        });
      } else {
        resolve_query_promise(value);

        set_query_state({
          status: QueryStatus.complete,
          value: value,
          promise: query_state.promise,
        });
      }
    });
  }

  return {
    run,
    ...query_state,
  };
}

type MapUnpacked<T, V> = T extends (infer U)[]
  ? (value: U) => V
  : (value: T) => V;

export function QueryWrapper<T>({
  result,
  mapper,
}: {
  result: QueryResult<T> | QueryResult<T[]>;
  mapper: MapUnpacked<T, JSX.Element>;
}) {
  if (result.status == QueryStatus.loading) {
    return <div>Loading...</div>;
  } else if (result.status == QueryStatus.errored) {
    return <div>Errored</div>;
  } else if (result.status == QueryStatus.idle) {
    return <div>Idle</div>;
  } else {
    if (Array.isArray(result.value)) {
      return <div>{result.value.map((value) => mapper(value))}</div>;
    } else {
      return <div>{mapper(result.value)}</div>;
    }
  }
}

// Attach the promise generated by the query to all combinations of QueryResult to allow for branching from the promise in application logic
type InternalQueryResult<T> = (Idle | Loading | Errored | Complete<T>) & {
  promise: Promise<T>;
};

export type QueryResult<T> = InternalQueryResult<T> & { run: () => void };

export enum QueryStatus {
  idle = "idle",
  loading = "loading",
  errored = "errored",
  complete = "complete",
}

interface Idle {
  status: QueryStatus.idle;
}

interface Loading {
  status: QueryStatus.loading;
}

interface Errored {
  status: QueryStatus.errored;
  message: string;
}

interface Complete<T> {
  status: QueryStatus.complete;
  value: T;
}
