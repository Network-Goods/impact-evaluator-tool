import { Dispatch, SetStateAction, useEffect, useState } from "react";


export interface WrappedReactive<T> {
    value: T;
    set_value: Dispatch<SetStateAction<T>>;
}

export function wrap_use_state<T>(initial: T): WrappedReactive<T> {
    let [value, set_value] = useState<T>(initial);

    return {
        value,
        set_value,
    }
}

export function wrap_query<T>(f: (() => Promise<T>) | Promise<T>): QueryResult<T> {
    let promise = typeof f === 'function' ? f() : f;

    let [value, set_value] = useState<QueryResult<T>>({
             status: QueryStatus.loading,
             promise: promise,
        });

    useEffect(() => {
        console.log('using effect');
        promise.then((value) => {
            set_value({
                status: QueryStatus.complete,
                value: value,
                promise: promise,
            });
        }).catch((reason) => {
            console.error('wrap_query failed:', reason);
            set_value({
                status: QueryStatus.errored,
                message: reason.message,
                promise: promise,
            });
        })
    }, []);

    return value as any;
}


// Attach the promise generated by the query to all combinations of QueryResult to allow for branching from the promise in application logic
export type QueryResult<T> = (Loading | Errored | { status: QueryStatus.complete, value: T }) & { promise: Promise<T> };

export enum QueryStatus {
    loading = 'loading',
    errored = 'errored',
    complete = 'complete',
}

interface Loading {
    status: QueryStatus.loading,
}

interface Errored {
    status: QueryStatus.errored,
    message: string,
}